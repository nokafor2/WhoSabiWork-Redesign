image: node:18-buster

stages:
  - build
  - test
  - deploy

cache:
  paths:
    - node_modules/
    - vendor/

variables:
  SSH_HOST: ec2-user@ec2-13-40-186-156.eu-west-2.compute.amazonaws.com
  SSH_PORT: 22

.before_script:
  - apt-get update -y
  - apt-get install -y openssh-client rsync

# working
build:
  stage: build
  script:
    - npm install
    - npm run build
    # - composer install --no-dev --optimize-autoloader
    # - composer install --no-dev
  artifacts:
    paths:
      - public/
      - vendor/
      - node_modules/

# working
install_composer:
  stage: build
  image: php:8.2-cli  # Use a PHP image with CLI
  script:
    - php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
    - php composer-setup.php --install-dir=/usr/local/bin --filename=composer
    # Now you can run composer commands
    - composer install
    - composer --version  # Verify installation

# Not working
.test:
  stage: test
  script:
    - php artisan test

ssh_deploy:
  stage: deploy
  image: alpine
  before_script:
    # STEP 1: Test for connection with the server
    # Check if id address and port 22 is open on the server
    - nc -zv $REMOTE_DEPLOY_HOST $SSH_PORT

    # STEP 2: Change the permission of the SSH_PRIVATE_KEY file
    # View the SSH_PRIVATE_KEY
    # - echo $SSH_PRIVATE_KEY
    # - cat $SSH_PRIVATE_KEY
    # Chcek permissions
    # - ls -l $SSH_PRIVATE_KEY
    # change permission of key to only the owner
    # Grant read-only permission to the private key
    - chmod 400 $SSH_PRIVATE_KEY
    # - ls -l $SSH_PRIVATE_KEY

    # STEP 3: SSH Connection
    # install the Openssh client, and rsync
    - apk add openssh-client rsync zip
    # ssh-agent is a background process that manages SSH-keys
    # Use ssh-agent to add our SSH-key
    # When ssh-agent runs, it outputs to the console some variables that interact with it
    # For it to work, it is put in a sub-shell $()
    # The eval is used to set the environment variables in current shell session
    - eval $(ssh-agent)
    # add the SSH_PRIVATE_KEY to the installed SSH environment with the file path variable
    # After added, tools like SSH, SCP can use the SSH-key for authentication
    - ssh-add $SSH_PRIVATE_KEY
    # Connect to the server
    # This is not a secure way of connecting to the server, just for testing purposes
    # - ssh -o StrictHostKeyChecking=no $REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST

    # STEP 4: Connect to the server
    # Create the SSH directory and assign the right permissions
    # Use ssh-keyscan <ip address> to get a finger print of the server
    # The ssh-keyscan command should not be executed on the GitLab runner to avoid man in the middle attack
    # Some one can instead swap the ip-address
    # Use ssh-keyscan <ip host name> to get a finger print of the server also, it would be different
    # Save the none commented values to the env. variable SSH_KNOWN_HOSTS file
    # Create the .ssh folder if it doesn't exist
    # The '-p' is used to avoid getting an error if the folder already exist
    - mkdir -p ~/.ssh
    # Set the write permission to the .ssh directory
    - chmod 700 ~/.ssh
    # copy SSH_KNOWN_HOSTS file to the .ssh/known_hosts folder
    - cp $SSH_KNOWN_HOSTS ~/.ssh/known_hosts
    # Set the write permission to the file
    - chmod 644 ~/.ssh/known_hosts
  script:
    # STEP 4: Connect to the server
    # Now connect to the recognized server
    # - ssh $REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST "whoami"

    # STEP 5: Testing upload of files to the server
    # Create a file
    # - touch bar.txt
    # Copy files using the remote command securely 'scp'
    # specify the copied file where to upload it
    # - scp bar.txt $REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:/tmp
    # Open SSH connection and connect to the server + Run commands
    # - ssh $REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST "whoami; touch /tmp/foo.txt; ls -l /tmp"

    # STEP 6: Upload the website files to the server
    # Open SSH connection and connect to the server + Run commands
    # - ssh $REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST "whoami; touch /tmp/foo.txt; ls -l /tmp"
    # specify the copied file where to upload it
    # copy all files and directory (contents) from the build directory
    # The path to copy to is: '/usr/share/nginx/html/'
    # Ensure to change ownership of files from root user to ec2-user on the server
    # Run: sudo chown -R ec2-user:ec2-user /usr/share/nginx/html/
    # Use the '-r' copying recursively to copy all files and directories
    # - scp -r public/* $REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:/usr/share/nginx/html/
    # Run: sudo chown -R ec2-user:ec2-user /var/www/html/WhoSabiWork-Redesign/
    # - scp -r ./* $REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:/var/www/html/WhoSabiWork-Redesign/

    # STEP 7: Upload files using rsync instead of scp
    # rsync allows to sychnronize only changed files between a local and remote directory
    # rsync has to be installed, it doesn't come with alpine
    # '-v' option makes the rsync chatty and gives feedback
    # '-z' option compresses the data
    # '--delete' to give permission to delete files from the server that are not local in the build directory
    # - rsync -rvz --delete public/ $REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:/usr/share/nginx/html/
    # Modify the above
    # - chown -R ec2-user:ec2-user /var/www/html/WhoSabiWork-Redesign/
    - ssh $SSH_HOST "sudo chown -R ec2-user:ec2-user /var/www/html/WhoSabiWork-Redesign/"
    - rsync -avz --exclude node_modules --exclude vendor --delete-after ./ $REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:/var/www/html/WhoSabiWork-Redesign/
    # - ssh $SSH_HOST << EOF
    #     cp /var/www/html/WhoSabiWork-Redesign/.env.production /var/www/html/WhoSabiWork-Redesign/.env
    #     cd /var/www/html/WhoSabiWork-Redesign
    #     php artisan migrate
    #     php artisan config:cache
    #     php artisan route:cache
    #     sudo chmod -R 775 /var/www/html/storage
    #     sudo chmod -R 775 /var/www/html/bootstrap/cache
    #     sudo systemctl restart php-fpm
    #     sudo systemctl restart nginx
    #   EOF
    
    # - ssh $SSH_HOST "cp /var/www/html/WhoSabiWork-Redesign/.env.production /var/www/html/WhoSabiWork-Redesign/.env; cd /var/www/html/WhoSabiWork-Redesign"
    - ssh $SSH_HOST "cp /var/www/html/WhoSabiWork-Redesign/.env.production /var/www/html/WhoSabiWork-Redesign/.env"
    - ssh $SSH_HOST "cd /var/www/html/WhoSabiWork-Redesign; php artisan migrate; php artisan config:cache; php artisan route:cache"
    # - ssh $SSH_HOST "php artisan migrate"
    # - ssh $SSH_HOST "php artisan config:cache"
    # - ssh $SSH_HOST "php artisan route:cache"
    - ssh $SSH_HOST "sudo chmod -R 775 /var/www/html/storage"
    - ssh $SSH_HOST "sudo chmod -R 775 /var/www/html/bootstrap/cache"
    - ssh $SSH_HOST "sudo systemctl restart php-fpm"
    - ssh $SSH_HOST "sudo systemctl restart nginx"


    # STEP 8: Upload files using a deploy script
    # Create the zip file, zip is not part of alpine, so install it
    # - zip -r public.zip public/
    # with scp, you can upload multiple files simultaneously
    # save to a deploy folder and not directly into the nginx user path
    # - scp public.zip ci/deploy.sh $REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:~/deploy
    # To run the deploy script, it has to be executeable, so change its permission
    # - ssh $REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST "cd ~/deploy; chmod +x deploy.sh; ./deploy.sh"

.deploy:
  stage: deploy
  script:
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -H $SSH_HOST >> ~/.ssh/known_hosts
    - rsync -avz --exclude node_modules --exclude vendor --delete-after . $SSH_HOST:/var/www/laravel-app
    - ssh $SSH_HOST "cd /var/www/laravel-app && composer install --no-dev && npm install && npm run build && php artisan migrate --force && php artisan config:cache && php artisan route:cache"
